<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>環面直落四子 - FuLab</title>
  <link rel="stylesheet" href="fulab-theme.css">
  <style>
    .boardWrap { display: flex; justify-content: center; }
    .board {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
      width: min(100%, 520px);
    }
    .colBtn {
      height: 36px;
      border-radius: 12px;
      border: 1px solid var(--fulab-silver);
      background: var(--fulab-paper);
      cursor: pointer;
      font-weight: 650;
      transition: border-color 120ms ease, background 120ms ease;
    }
    .colBtn:hover { border-color: var(--fulab-teal); }
    .colBtn:disabled { opacity: .5; cursor: not-allowed; }
    .grid {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
    }
    .cell {
      aspect-ratio: 1 / 1;
      border: 1px solid var(--fulab-silver);
      border-radius: 12px;
      background: var(--fulab-bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(28px, 8vw, 42px);
      position: relative;
    }
    .cell.win { background: var(--fulab-tint-emerald); border-color: var(--fulab-emerald); }
    .cell.last { box-shadow: 0 0 0 2px var(--fulab-tint-indigo); }
    .info { text-align: center; margin: 10px 0; font-weight: 650; }
  </style>
</head>
<body>
  <main>
    <section class="card">
      <h1>環面直落四子</h1>
      <p class="lead">經典 7×6 直落四子，加上「環面」判定：連線可繞過左右/上下邊界。棋子改為黑白。</p>
      <div class="boardWrap">
        <div class="board">
          <button class="colBtn" data-col="0">↓</button>
          <button class="colBtn" data-col="1">↓</button>
          <button class="colBtn" data-col="2">↓</button>
          <button class="colBtn" data-col="3">↓</button>
          <button class="colBtn" data-col="4">↓</button>
          <button class="colBtn" data-col="5">↓</button>
          <button class="colBtn" data-col="6">↓</button>
          <div class="grid" id="grid"></div>
        </div>
      </div>
      <div class="info" id="statusText"></div>
      <div class="pillRow">
        <span class="pill">回合：<strong id="turnKpi">0</strong></span>
        <span class="pill">玩家：<strong id="playerKpi">黑</strong></span>
      </div>
      <div class="btnRow">
        <button class="btn primary" id="newGame">新局</button>
        <button class="btn secondary" id="reset">重置</button>
      </div>
    </section>

    <section class="card">
      <h2 class="sectionTitle">規則</h2>
      <ul class="list">
        <li>落子方式與經典四子棋相同：點選欄位，棋子直落到最底的空格。</li>
        <li>環面判定：橫、直、斜線可越界再回到另一側，只要連續四顆同色即勝。</li>
        <li>若棋盤填滿且無連線則平手。</li>
      </ul>
    </section>
  </main>

  <script>
    const ROWS = 6, COLS = 7;
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('statusText');
    const turnEl = document.getElementById('turnKpi');
    const playerEl = document.getElementById('playerKpi');
    const colBtns = Array.from(document.querySelectorAll('.colBtn'));
    const newBtn = document.getElementById('newGame');
    const resetBtn = document.getElementById('reset');

    let board, player, turn, over, winCells, lastMove;

    function reset() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(''));
      player = 'B'; // B = 黑, W = 白
      turn = 0;
      over = false;
      winCells = new Set();
      lastMove = null;
      render();
    }

    function drop(col) {
      if (over) return;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r][col] === '') {
          board[r][col] = player;
          lastMove = `${r}-${col}`;
          turn++;
          const wl = checkWin(r, col);
          if (wl) {
            over = true;
            wl.forEach(k => winCells.add(k));
            render();
            return;
          }
          if (turn >= ROWS * COLS) {
            over = true;
            render();
            return;
          }
          player = (player === 'B') ? 'W' : 'B';
          render();
          return;
        }
      }
    }

    // Wrap-aware win detection
    function checkWin(r, c) {
      const directions = [
        [1, 0], [0, 1], [1, 1], [1, -1]
      ];
      for (const [dr, dc] of directions) {
        const cells = [];
        for (let k = 0; k < 4; k++) {
          const rr = (r + dr * k + ROWS) % ROWS;
          const cc = (c + dc * k + COLS) % COLS;
          cells.push(`${rr}-${cc}`);
        }
          const val = cells.map(keyToVal).every(v => v === player);
        if (val) return cells;
      }
      // also need to scan backwards start to catch other sequences
      for (const [dr, dc] of directions) {
        for (let offset = -3; offset <= 0; offset++) {
          const cells2 = [];
          for (let k = 0; k < 4; k++) {
            const rr = (r + dr * (offset + k) + ROWS) % ROWS;
            const cc = (c + dc * (offset + k) + COLS) % COLS;
            cells2.push(`${rr}-${cc}`);
          }
          const val2 = cells2.map(keyToVal).every(v => v === player);
          if (val2) return cells2;
        }
      }
      return null;
    }

    function keyToVal(key) {
      const [r, c] = key.split('-').map(Number);
      return board[r][c];
    }

    function render() {
      gridEl.innerHTML = '';
      turnEl.textContent = String(turn);
      playerEl.textContent = (player === 'B') ? '黑' : '白';

      const fullCols = new Set();
      for (let c = 0; c < COLS; c++) {
        if (board[0][c] !== '') fullCols.add(c);
      }
      colBtns.forEach(btn => {
        const col = Number(btn.dataset.col);
        btn.disabled = over || fullCols.has(col);
        btn.onclick = () => drop(col);
      });

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          const key = `${r}-${c}`;
          const v = board[r][c];
          cell.textContent = v ? symbol(v) : '';
          if (v === 'B') {
            cell.style.color = '#2E3440';
            cell.style.textShadow = '';
          } else if (v === 'W') {
            cell.style.color = '#FFFFFF';
            cell.style.textShadow = '0 0 2px #2E3440, 0 0 1px #2E3440';
          } else {
            cell.style.color = '';
            cell.style.textShadow = '';
          }
          if (winCells.has(key)) cell.classList.add('win');
          if (lastMove === key) cell.classList.add('last');
          gridEl.appendChild(cell);
        }
      }

      if (over) {
        if (winCells.size > 0) {
        statusEl.textContent = `${playerEl.textContent} 連成四子！`;
      } else {
        statusEl.textContent = '平手，棋盤已滿。';
      }
    } else {
      statusEl.textContent = `輪到 ${playerEl.textContent}`;
    }
    }

    newBtn.addEventListener('click', reset);
    resetBtn.addEventListener('click', reset);
    reset();

    function symbol(v) {
      if (v === 'B') return '●';
      if (v === 'W') return '○';
      return '';
    }
  </script>
</body>
</html>
