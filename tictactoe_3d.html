<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D 三子棋 (3×3×3) - FuLab</title>
  <link rel="stylesheet" href="fulab-theme.css">
  <style>
    .stack { display: flex; justify-content: center; padding: 12px 0 4px; }
    .scene { perspective: 1400px; width: 100%; display: flex; justify-content: center; }
    .layerStack {
      position: relative;
      width: min(92vw, 420px);
      height: min(88vw, 420px);
      transform-style: preserve-3d;
      transform: rotateX(var(--rotX, 26deg)) rotateY(var(--rotY, -28deg));
      transition: transform 180ms ease;
      --layerZ: 120px;
      --layerY: 68px;
    }
    .layer {
      position: absolute;
      left: 50%;
      top: 50%;
      width: min(70vw, 340px);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      transform-style: preserve-3d;
      transform: translate(-50%, -50%)
                 translateZ(calc((1 - var(--z, 1)) * var(--layerZ, 80px)))
                 translateY(calc((var(--z, 1) - 1) * var(--layerY, 34px)));
    }

    .cell {
      aspect-ratio: 1 / 1;
      border: 1px solid var(--fulab-silver);
      border-radius: 12px;
      background: var(--fulab-bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(28px, 8vw, 46px);
      cursor: pointer;
      transition: border-color 120ms ease, background-color 120ms ease;
    }
    .cell:hover { border-color: var(--fulab-teal); }
    .cell.win { background: var(--fulab-tint-emerald); border-color: var(--fulab-emerald); }
    .cell.last { box-shadow: 0 0 0 2px var(--fulab-tint-indigo); }
    .cell:disabled { cursor: not-allowed; opacity: .7; }

    .legend { display: flex; gap: 10px; flex-wrap: wrap; }
    .legend span { display: inline-flex; align-items: center; gap: 6px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
    .dot.x { background: var(--fulab-graphite); }
    .dot.o { background: var(--fulab-teal); }

    .orientationRow { display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-end; }
    .rotateBtns { display: flex; gap: 8px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <main>
    <section class="card">
      <h1>3D 三子棋（3×3×3）</h1>
      <p class="lead">三層 3×3 立體棋盤，任何方向的三連線都能獲勝。提供同機對戰與簡易 AI，視角可旋轉避免遮蔽。</p>

      <div class="stack">
        <div class="scene">
          <div class="layerStack" id="layers"></div>
        </div>
      </div>

      <div class="pillRow">
        <span class="pill">回合：<strong id="turnKpi">0</strong></span>
        <span class="pill">玩家：<strong id="playerKpi">X</strong></span>
        <span class="pill">模式：<strong id="modeKpi">同機</strong></span>
        <span class="pill">視角：<strong id="faceKpi">Z 正面</strong></span>
      </div>
      <div class="info" id="statusText"></div>

      <div class="fieldGrid">
        <div class="field">
          <label for="mode">模式</label>
          <select id="mode">
            <option value="pvp">雙人同機</option>
            <option value="ai">對戰 AI（AI = O）</option>
          </select>
        </div>

        <div class="field">
          <label for="faceSelect">前方朝向</label>
          <select id="faceSelect">
            <option value="z+">Z 正面（預設）</option>
            <option value="z-">Z 背面</option>
            <option value="x+">X 正面</option>
            <option value="x-">X 背面</option>
            <option value="y+">Y 正面</option>
            <option value="y-">Y 背面</option>
          </select>
        </div>
      </div>

      <div class="orientationRow">
        <div class="rotateBtns">
          <button class="btn secondary" id="rotLeft">左轉</button>
          <button class="btn secondary" id="rotRight">右轉</button>
          <button class="btn secondary" id="rotUp">上轉</button>
          <button class="btn secondary" id="rotDown">下轉</button>
        </div>
        <span class="text-small">提示：可切換前方朝向或微調旋轉，避免棋位遮蔽。</span>
      </div>

      <div class="btnRow">
        <button class="btn primary" id="newGame">新局</button>
        <button class="btn secondary" id="reset">重置</button>
      </div>

      <div class="legend text-small">
        <span><span class="dot x"></span> X</span>
        <span><span class="dot o"></span> O</span>
        <span>上層 = Z0（靠近視角），下層 = Z2（遠離視角）。</span>
      </div>
    </section>

    <section class="card">
      <h2 class="sectionTitle">規則</h2>
      <ul class="list">
        <li>棋盤為 3×3×3，輪流落子；任一方向三連線即獲勝。</li>
        <li>勝利方向包含：X/Y/Z 軸直線、每層對角線、縱深對角線以及 4 條空間對角線。</li>
        <li>AI 模式：玩家為 X 先手；AI 使用簡易「立即勝利/阻擋」優先的策略。</li>
      </ul>
    </section>
  </main>

  <script>
    const layersEl = document.getElementById('layers');
    const statusEl = document.getElementById('statusText');
    const turnEl = document.getElementById('turnKpi');
    const playerEl = document.getElementById('playerKpi');
    const modeEl = document.getElementById('mode');
    const modeKpiEl = document.getElementById('modeKpi');
    const faceSelect = document.getElementById('faceSelect');
    const faceKpi = document.getElementById('faceKpi');
    const newBtn = document.getElementById('newGame');
    const resetBtn = document.getElementById('reset');
    const rotLeft = document.getElementById('rotLeft');
    const rotRight = document.getElementById('rotRight');
    const rotUp = document.getElementById('rotUp');
    const rotDown = document.getElementById('rotDown');

    let board, player, turn, over, winSet, lastIdx, mode;
    const cells = [];
    let face = 'z+';
    let rotX = 26;
    let rotY = -28;

    const lines = buildLines();

    function idx(x, y, z) { return z * 9 + y * 3 + x; }
    function coord(i) { return { z: Math.floor(i / 9), y: Math.floor((i % 9) / 3), x: i % 3 }; }

    function buildLines() {
      const ls = [];
      // axis lines
      for (let z = 0; z < 3; z++) {
        for (let y = 0; y < 3; y++) ls.push([idx(0,y,z), idx(1,y,z), idx(2,y,z)]);
        for (let x = 0; x < 3; x++) ls.push([idx(x,0,z), idx(x,1,z), idx(x,2,z)]);
      }
      for (let x = 0; x < 3; x++) for (let y = 0; y < 3; y++) ls.push([idx(x,y,0), idx(x,y,1), idx(x,y,2)]);
      // plane diagonals
      for (let z = 0; z < 3; z++) {
        ls.push([idx(0,0,z), idx(1,1,z), idx(2,2,z)]);
        ls.push([idx(2,0,z), idx(1,1,z), idx(0,2,z)]);
      }
      for (let y = 0; y < 3; y++) {
        ls.push([idx(0,y,0), idx(1,y,1), idx(2,y,2)]);
        ls.push([idx(2,y,0), idx(1,y,1), idx(0,y,2)]);
      }
      for (let x = 0; x < 3; x++) {
        ls.push([idx(x,0,0), idx(x,1,1), idx(x,2,2)]);
        ls.push([idx(x,2,0), idx(x,1,1), idx(x,0,2)]);
      }
      // space diagonals
      ls.push([idx(0,0,0), idx(1,1,1), idx(2,2,2)]);
      ls.push([idx(2,0,0), idx(1,1,1), idx(0,2,2)]);
      ls.push([idx(0,2,0), idx(1,1,1), idx(2,0,2)]);
      ls.push([idx(2,2,0), idx(1,1,1), idx(0,0,2)]);
      return ls;
    }

    function reset() {
      board = Array(27).fill('');
      player = 'X';
      turn = 0;
      over = false;
      winSet = new Set();
      lastIdx = null;
      mode = modeEl.value;
      face = faceSelect.value;
      applyFacePreset(face);
      render();
    }

    function checkWin(p) {
      for (const line of lines) {
        if (line.every(i => board[i] === p)) return line;
      }
      return null;
    }

    function applyMove(i) {
      if (over) return;
      if (board[i] !== '') return;
      board[i] = player;
      lastIdx = i;
      turn++;

      const wl = checkWin(player);
      if (wl) {
        over = true;
        winSet = new Set(wl);
        render();
        return;
      }
      if (turn >= 27) {
        over = true;
        render();
        return;
      }
      player = (player === 'X') ? 'O' : 'X';
      render();

      if (!over && mode === 'ai' && player === 'O') {
        setTimeout(aiMove, 20);
      }
    }

    function aiMove() {
      const move = pickAiMove();
      if (move != null) applyMove(move);
    }

    function pickAiMove() {
      const empties = board.map((v,i) => v === '' ? i : null).filter(v => v !== null);
      if (empties.length === 0) return null;

      // 1) win now
      for (const i of empties) {
        board[i] = 'O';
        if (checkWin('O')) { board[i] = ''; return i; }
        board[i] = '';
      }
      // 2) block X win
      for (const i of empties) {
        board[i] = 'X';
        if (checkWin('X')) { board[i] = ''; return i; }
        board[i] = '';
      }
      // 3) center preference
      const center = idx(1,1,1);
      if (board[center] === '') return center;
      // 4) corners preference
      const corners = [idx(0,0,0), idx(0,0,2), idx(0,2,0), idx(0,2,2), idx(2,0,0), idx(2,0,2), idx(2,2,0), idx(2,2,2)];
      for (const c of corners) if (board[c] === '') return c;
      // 5) otherwise random
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function render() {
      layersEl.innerHTML = '';
      turnEl.textContent = String(turn);
      playerEl.textContent = player;
      modeKpiEl.textContent = mode === 'ai' ? 'AI 對戰' : '同機';
      faceKpi.textContent = faceLabel(face);

      for (let z = 0; z < 3; z++) {
        const layer = document.createElement('div');
        layer.className = 'layer';
        layer.dataset.z = String(z);
        layer.style.setProperty('--z', String(z));
        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const i = idx(x,y,z);
            const cell = document.createElement('button');
            cell.className = 'cell';
            const v = board[i];
            cell.textContent = v;
            cell.disabled = over || v !== '' || (mode === 'ai' && player === 'O');
            if (winSet.has(i)) cell.classList.add('win');
            if (lastIdx === i) cell.classList.add('last');
            cell.addEventListener('click', () => applyMove(i));
            layer.appendChild(cell);
          }
        }
        layersEl.appendChild(layer);
      }

      if (over) {
        if (winSet.size > 0) statusEl.textContent = `${player} 取得三連線！`;
        else statusEl.textContent = '平手，棋盤已滿。';
      } else {
        statusEl.textContent = (mode === 'ai' && player === 'O') ? 'AI 思考中…' : `輪到 ${player}`;
      }

      setSceneRotation(rotX, rotY);
    }

    function faceLabel(f) {
      return {
        'z+': 'Z 正面',
        'z-': 'Z 背面',
        'x+': 'X 正面',
        'x-': 'X 背面',
        'y+': 'Y 正面',
        'y-': 'Y 背面',
        'custom': '自訂視角'
      }[f] || '自訂視角';
    }

    function applyFacePreset(f) {
      const preset = {
        'z+': { x: 26, y: -28 },
        'z-': { x: 26, y: 152 },
        'x+': { x: 26, y: -118 },
        'x-': { x: 26, y: 62 },
        'y+': { x: -58, y: -28 },
        'y-': { x: 64, y: -28 }
      }[f];
      if (preset) {
        rotX = preset.x;
        rotY = preset.y;
        setSceneRotation(rotX, rotY);
      }
    }

    function setSceneRotation(xDeg, yDeg) {
      layersEl.style.setProperty('--rotX', `${xDeg}deg`);
      layersEl.style.setProperty('--rotY', `${yDeg}deg`);
    }

    function nudge(dx=0, dy=0) {
      rotY += dx;
      rotX += dy;
      setSceneRotation(rotX, rotY);
    }

    modeEl.addEventListener('change', () => { mode = modeEl.value; render(); if (!over && mode === 'ai' && player === 'O') aiMove(); });
    faceSelect.addEventListener('change', () => { face = faceSelect.value; applyFacePreset(face); render(); });
    rotLeft.addEventListener('click', () => { face = 'custom'; nudge(-12, 0); render(); });
    rotRight.addEventListener('click', () => { face = 'custom'; nudge(12, 0); render(); });
    rotUp.addEventListener('click', () => { face = 'custom'; nudge(0, -10); render(); });
    rotDown.addEventListener('click', () => { face = 'custom'; nudge(0, 10); render(); });
    newBtn.addEventListener('click', reset);
    resetBtn.addEventListener('click', reset);
    reset();
  </script>
</body>
</html>
