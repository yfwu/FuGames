<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D 三子棋 (3×3×3) - FuLab</title>
  <link rel="stylesheet" href="fulab-theme.css">
  <style>
    .stack {
      perspective: 900px;
      display: flex;
      justify-content: center;
      padding: 12px 0 4px;
    }
    .layerStack {
      position: relative;
      width: min(92vw, 420px);
      height: min(72vw, 320px);
    }
    .layer {
      position: absolute;
      left: 50%;
      top: 50%;
      width: min(70vw, 320px);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      transform-style: preserve-3d;
      transform-origin: center;
      transition: transform 160ms ease;
    }
    .layer[data-z="0"] { transform: translate(-50%, -50%) translateY(-36px) translateZ(40px) rotateX(22deg); }
    .layer[data-z="1"] { transform: translate(-50%, -50%) rotateX(22deg); }
    .layer[data-z="2"] { transform: translate(-50%, -50%) translateY(36px) translateZ(-40px) rotateX(22deg); }

    .cell {
      aspect-ratio: 1 / 1;
      border: 1px solid var(--fulab-silver);
      border-radius: 12px;
      background: var(--fulab-bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(28px, 8vw, 46px);
      cursor: pointer;
      transition: border-color 120ms ease, background-color 120ms ease;
    }
    .cell:hover { border-color: var(--fulab-teal); }
    .cell.win { background: var(--fulab-tint-emerald); border-color: var(--fulab-emerald); }
    .cell.last { box-shadow: 0 0 0 2px var(--fulab-tint-indigo); }
    .cell:disabled { cursor: not-allowed; opacity: .7; }

    .legend { display: flex; gap: 10px; flex-wrap: wrap; }
    .legend span { display: inline-flex; align-items: center; gap: 6px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
    .dot.x { background: var(--fulab-graphite); }
    .dot.o { background: var(--fulab-teal); }
  </style>
</head>
<body>
  <main>
    <section class="card">
      <h1>3D 三子棋（3×3×3）</h1>
      <p class="lead">三層 3×3 立體棋盤，任何方向的三連線都能獲勝。提供同機對戰與簡易 AI。</p>

      <div class="stack">
        <div class="layerStack" id="layers"></div>
      </div>

      <div class="pillRow">
        <span class="pill">回合：<strong id="turnKpi">0</strong></span>
        <span class="pill">玩家：<strong id="playerKpi">X</strong></span>
        <span class="pill">模式：<strong id="modeKpi">同機</strong></span>
      </div>
      <div class="info" id="statusText"></div>

      <div class="fieldGrid">
        <div class="field">
          <label for="mode">模式</label>
          <select id="mode">
            <option value="pvp">雙人同機</option>
            <option value="ai">對戰 AI（AI = O）</option>
          </select>
        </div>
      </div>

      <div class="btnRow">
        <button class="btn primary" id="newGame">新局</button>
        <button class="btn secondary" id="reset">重置</button>
      </div>

      <div class="legend text-small">
        <span><span class="dot x"></span> X</span>
        <span><span class="dot o"></span> O</span>
        <span>上層 = Z0（靠近視角），下層 = Z2（遠離視角）。</span>
      </div>
    </section>

    <section class="card">
      <h2 class="sectionTitle">規則</h2>
      <ul class="list">
        <li>棋盤為 3×3×3，輪流落子；任一方向三連線即獲勝。</li>
        <li>勝利方向包含：X/Y/Z 軸直線、每層對角線、縱深對角線以及 4 條空間對角線。</li>
        <li>AI 模式：玩家為 X 先手；AI 使用簡易「立即勝利/阻擋」優先的策略。</li>
      </ul>
    </section>
  </main>

  <script>
    const layersEl = document.getElementById('layers');
    const statusEl = document.getElementById('statusText');
    const turnEl = document.getElementById('turnKpi');
    const playerEl = document.getElementById('playerKpi');
    const modeEl = document.getElementById('mode');
    const modeKpiEl = document.getElementById('modeKpi');
    const newBtn = document.getElementById('newGame');
    const resetBtn = document.getElementById('reset');

    let board, player, turn, over, winSet, lastIdx, mode;
    const cells = [];

    const lines = buildLines();

    function idx(x, y, z) { return z * 9 + y * 3 + x; }
    function coord(i) { return { z: Math.floor(i / 9), y: Math.floor((i % 9) / 3), x: i % 3 }; }

    function buildLines() {
      const ls = [];
      // axis lines
      for (let z = 0; z < 3; z++) {
        for (let y = 0; y < 3; y++) ls.push([idx(0,y,z), idx(1,y,z), idx(2,y,z)]);
        for (let x = 0; x < 3; x++) ls.push([idx(x,0,z), idx(x,1,z), idx(x,2,z)]);
      }
      for (let x = 0; x < 3; x++) for (let y = 0; y < 3; y++) ls.push([idx(x,y,0), idx(x,y,1), idx(x,y,2)]);
      // plane diagonals
      for (let z = 0; z < 3; z++) {
        ls.push([idx(0,0,z), idx(1,1,z), idx(2,2,z)]);
        ls.push([idx(2,0,z), idx(1,1,z), idx(0,2,z)]);
      }
      for (let y = 0; y < 3; y++) {
        ls.push([idx(0,y,0), idx(1,y,1), idx(2,y,2)]);
        ls.push([idx(2,y,0), idx(1,y,1), idx(0,y,2)]);
      }
      for (let x = 0; x < 3; x++) {
        ls.push([idx(x,0,0), idx(x,1,1), idx(x,2,2)]);
        ls.push([idx(x,2,0), idx(x,1,1), idx(x,0,2)]);
      }
      // space diagonals
      ls.push([idx(0,0,0), idx(1,1,1), idx(2,2,2)]);
      ls.push([idx(2,0,0), idx(1,1,1), idx(0,2,2)]);
      ls.push([idx(0,2,0), idx(1,1,1), idx(2,0,2)]);
      ls.push([idx(2,2,0), idx(1,1,1), idx(0,0,2)]);
      return ls;
    }

    function reset() {
      board = Array(27).fill('');
      player = 'X';
      turn = 0;
      over = false;
      winSet = new Set();
      lastIdx = null;
      mode = modeEl.value;
      render();
    }

    function checkWin(p) {
      for (const line of lines) {
        if (line.every(i => board[i] === p)) return line;
      }
      return null;
    }

    function applyMove(i) {
      if (over) return;
      if (board[i] !== '') return;
      board[i] = player;
      lastIdx = i;
      turn++;

      const wl = checkWin(player);
      if (wl) {
        over = true;
        winSet = new Set(wl);
        render();
        return;
      }
      if (turn >= 27) {
        over = true;
        render();
        return;
      }
      player = (player === 'X') ? 'O' : 'X';
      render();

      if (!over && mode === 'ai' && player === 'O') {
        setTimeout(aiMove, 20);
      }
    }

    function aiMove() {
      const move = pickAiMove();
      if (move != null) applyMove(move);
    }

    function pickAiMove() {
      const empties = board.map((v,i) => v === '' ? i : null).filter(v => v !== null);
      if (empties.length === 0) return null;

      // 1) win now
      for (const i of empties) {
        board[i] = 'O';
        if (checkWin('O')) { board[i] = ''; return i; }
        board[i] = '';
      }
      // 2) block X win
      for (const i of empties) {
        board[i] = 'X';
        if (checkWin('X')) { board[i] = ''; return i; }
        board[i] = '';
      }
      // 3) center preference
      const center = idx(1,1,1);
      if (board[center] === '') return center;
      // 4) corners preference
      const corners = [idx(0,0,0), idx(0,0,2), idx(0,2,0), idx(0,2,2), idx(2,0,0), idx(2,0,2), idx(2,2,0), idx(2,2,2)];
      for (const c of corners) if (board[c] === '') return c;
      // 5) otherwise random
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function render() {
      layersEl.innerHTML = '';
      turnEl.textContent = String(turn);
      playerEl.textContent = player;
      modeKpiEl.textContent = mode === 'ai' ? 'AI 對戰' : '同機';

      for (let z = 0; z < 3; z++) {
        const layer = document.createElement('div');
        layer.className = 'layer';
        layer.dataset.z = String(z);
        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const i = idx(x,y,z);
            const cell = document.createElement('button');
            cell.className = 'cell';
            const v = board[i];
            cell.textContent = v;
            cell.disabled = over || v !== '' || (mode === 'ai' && player === 'O');
            if (winSet.has(i)) cell.classList.add('win');
            if (lastIdx === i) cell.classList.add('last');
            cell.addEventListener('click', () => applyMove(i));
            layer.appendChild(cell);
          }
        }
        layersEl.appendChild(layer);
      }

      if (over) {
        if (winSet.size > 0) statusEl.textContent = `${player} 取得三連線！`;
        else statusEl.textContent = '平手，棋盤已滿。';
      } else {
        statusEl.textContent = (mode === 'ai' && player === 'O') ? 'AI 思考中…' : `輪到 ${player}`;
      }
    }

    modeEl.addEventListener('change', () => { mode = modeEl.value; render(); if (!over && mode === 'ai' && player === 'O') aiMove(); });
    newBtn.addEventListener('click', reset);
    resetBtn.addEventListener('click', reset);
    reset();
  </script>
</body>
</html>
